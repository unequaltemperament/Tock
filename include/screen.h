#ifndef SCREEN_HEADER
#define SCREEN_HEADER

#include "debugSettings.h"
#include <Adafruit_GFX.h>
#include <Adafruit_ST7789.h>
#include "typeDefs.h"

#define CAPPED_NEOPIXEL_BRIGHTNESS 90
#define MAX_BACKLIGHT_BRIGHTNESS 127
#define BOOT_FADE_IN_TIME_MS 2000

static const byte splashImageData[1492] PROGMEM = {
    0x52, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00,
    0x52, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00,
    0x02, 0x90, 0x1A, 0x00, 0x02, 0x0B, 0x34, 0xFF, 0x00, 0x06, 0xFD,
    0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x02, 0x90, 0x1A, 0x00, 0x02,
    0x0B, 0x34, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00,
    0x00, 0x02, 0x90, 0x1A, 0x00, 0x02, 0x0B, 0x34, 0xFF, 0x00, 0x06, 0xFD,
    0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x02, 0x90, 0x1A, 0x00, 0x02,
    0x0B, 0x34, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00,
    0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x40, 0xFF, 0x00,
    0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x40, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02,
    0x00, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D,
    0x00, 0x40, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00,
    0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x40, 0xFF, 0x00,
    0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x40, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02,
    0x00, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D,
    0x00, 0x40, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00,
    0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x40, 0xFF, 0x00,
    0x06, 0xFD, 0x00, 0x02, 0x00, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x40, 0xFF, 0x00, 0x06, 0xFD, 0x00, 0x02,
    0x00, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D,
    0x00, 0x10, 0xFF, 0x00, 0x0C, 0xD8, 0x50, 0x00, 0x00, 0x68, 0xEF, 0x12,
    0xFF, 0x00, 0x18, 0xFB, 0x83, 0x00, 0x00, 0x08, 0x8E, 0xFF, 0xFF, 0xFF,
    0xFD, 0x00, 0x02, 0x12, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0,
    0x00, 0x0D, 0x00, 0x0E, 0xFF, 0x02, 0xC4, 0x0A, 0x00, 0x02, 0x05, 0x02,
    0xDF, 0x0E, 0xFF, 0x02, 0xFA, 0x02, 0x30, 0x0A, 0x00, 0x00, 0x0C, 0x4B,
    0xFF, 0xFF, 0xFD, 0x00, 0x02, 0x0A, 0xFF, 0x00, 0x08, 0x70, 0x00, 0x00,
    0x9F, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0C,
    0xFF, 0x02, 0xF7, 0x0E, 0x00, 0x02, 0x08, 0x0E, 0xFF, 0x02, 0x50, 0x0E,
    0x00, 0x00, 0x0A, 0x6F, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x08, 0xFF, 0x00,
    0x0A, 0xF6, 0x00, 0x00, 0x1C, 0xFF, 0x00, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0C, 0xFF, 0x00, 0x14, 0x40, 0x00, 0x01,
    0x8C, 0xFF, 0xFB, 0x80, 0x00, 0x00, 0x6F, 0x0A, 0xFF, 0x00, 0x1C, 0xE3,
    0x00, 0x00, 0x48, 0xFF, 0xFF, 0x84, 0x00, 0x00, 0x3C, 0xFF, 0xFD, 0x00,
    0x02, 0x08, 0xFF, 0x00, 0x0A, 0x60, 0x00, 0x02, 0xCF, 0xFF, 0x00, 0x00,
    0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0A, 0xFF, 0x00,
    0x16, 0xF5, 0x00, 0x00, 0x5F, 0xFF, 0xFF, 0xFF, 0xFE, 0x40, 0x00, 0x07,
    0x00, 0x0A, 0xFF, 0x00, 0x06, 0x30, 0x00, 0x0A, 0x00, 0x08, 0xFF, 0x00,
    0x20, 0x90, 0x04, 0xEF, 0xFF, 0xFD, 0x00, 0x02, 0xFF, 0xFF, 0xFF, 0xF4,
    0x00, 0x00, 0x2D, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0,
    0x00, 0x0D, 0x00, 0x0A, 0xFF, 0x00, 0x06, 0x80, 0x00, 0x08, 0x00, 0x0A,
    0xFF, 0x00, 0x16, 0xF6, 0x00, 0x00, 0xAF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
    0x00, 0xCF, 0x00, 0x08, 0xFF, 0x00, 0x20, 0xFB, 0x5F, 0xFF, 0xFF, 0xFD,
    0x00, 0x02, 0xFF, 0xFF, 0xFF, 0x40, 0x00, 0x03, 0xEF, 0xFF, 0xFF, 0x00,
    0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00,
    0x26, 0xFE, 0x10, 0x00, 0x5F, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0x30,
    0x00, 0x2F, 0xFF, 0xFF, 0xFF, 0xE1, 0x00, 0x08, 0x00, 0x12, 0xFF, 0x00,
    0x18, 0xFD, 0x00, 0x02, 0xFF, 0xFF, 0xE4, 0x00, 0x00, 0x4E, 0xFF, 0xFF,
    0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08,
    0xFF, 0x00, 0x26, 0xF8, 0x00, 0x00, 0xDF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF,
    0xFF, 0xB0, 0x00, 0x09, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x1E, 0x00, 0x12,
    0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xFE, 0x30, 0x00, 0x04, 0xFF,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D,
    0x00, 0x08, 0xFF, 0x00, 0x26, 0xF2, 0x00, 0x06, 0xFF, 0xFF, 0xFF, 0xF0,
    0xFF, 0xFF, 0xFF, 0xF4, 0x00, 0x04, 0xFF, 0xFF, 0xFF, 0x20, 0x00, 0x7F,
    0x00, 0x12, 0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xE3, 0x00, 0x00,
    0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0,
    0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00, 0x26, 0xC0, 0x00, 0x0A, 0xFF, 0xFF,
    0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0xEF, 0xFF, 0xFC, 0x00,
    0x00, 0xCF, 0x00, 0x12, 0xFF, 0x00, 0x0E, 0xFD, 0x00, 0x02, 0xFD, 0x20,
    0x00, 0x06, 0x00, 0x0A, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0,
    0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00, 0x26, 0x90, 0x00, 0x0E, 0xFF, 0xFF,
    0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0xBF, 0xFF, 0xF9, 0x00,
    0x00, 0xEF, 0x00, 0x12, 0xFF, 0x00, 0x0E, 0xFD, 0x00, 0x02, 0xD2, 0x00,
    0x00, 0x8F, 0x00, 0x0A, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0,
    0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00, 0x0E, 0x80, 0x00, 0x2F, 0xFF, 0xFF,
    0xFF, 0xF0, 0x00, 0x08, 0xFF, 0x00, 0x0E, 0x00, 0x00, 0x9F, 0xFF, 0xF8,
    0x00, 0x02, 0x00, 0x14, 0xFF, 0x00, 0x0C, 0xFD, 0x00, 0x01, 0x20, 0x00,
    0x08, 0x0C, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D,
    0x00, 0x08, 0xFF, 0x00, 0x0E, 0x80, 0x00, 0x2F, 0xFF, 0xFF, 0xFF, 0xF0,
    0x00, 0x08, 0xFF, 0x00, 0x0E, 0x00, 0x00, 0x9F, 0xFF, 0xF8, 0x00, 0x02,
    0x00, 0x14, 0xFF, 0x00, 0x0C, 0xFD, 0x00, 0x01, 0x20, 0x00, 0x08, 0x0C,
    0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08,
    0xFF, 0x00, 0x0E, 0x70, 0x00, 0x2F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x08,
    0xFF, 0x00, 0x0E, 0x00, 0x00, 0x8F, 0xFF, 0xF7, 0x00, 0x02, 0x00, 0x14,
    0xFF, 0x00, 0x0E, 0xFD, 0x00, 0x02, 0xD1, 0x00, 0x00, 0x8F, 0x00, 0x0A,
    0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08,
    0xFF, 0x00, 0x0E, 0x80, 0x00, 0x2F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x08,
    0xFF, 0x00, 0x0E, 0x00, 0x00, 0x9F, 0xFF, 0xF8, 0x00, 0x02, 0x00, 0x14,
    0xFF, 0x00, 0x0E, 0xFD, 0x00, 0x02, 0xFC, 0x10, 0x00, 0x08, 0x00, 0x0A,
    0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08,
    0xFF, 0x00, 0x0C, 0x90, 0x00, 0x0E, 0xFF, 0xFF, 0xF0, 0x08, 0xFF, 0x00,
    0x12, 0xFC, 0x00, 0x00, 0xBF, 0xFF, 0xF9, 0x00, 0x00, 0xEF, 0x00, 0x12,
    0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xC1, 0x00, 0x00, 0x8F, 0xFF,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D,
    0x00, 0x08, 0xFF, 0x00, 0x0C, 0xC0, 0x00, 0x0A, 0xFF, 0xFF, 0x0F, 0x08,
    0xFF, 0x00, 0x12, 0xF8, 0x00, 0x00, 0xEF, 0xFF, 0xFC, 0x00, 0x00, 0xAF,
    0x00, 0x12, 0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xFC, 0x00, 0x00,
    0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0,
    0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00, 0x0A, 0xF2, 0x00, 0x06, 0xFF, 0xF0,
    0x00, 0x0A, 0xFF, 0x00, 0x12, 0xF4, 0x00, 0x04, 0xFF, 0xFF, 0xFF, 0x10,
    0x00, 0x6F, 0x00, 0x12, 0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xFF,
    0xB0, 0x00, 0x00, 0x8F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00, 0x08, 0xF8, 0x00, 0x00,
    0xDF, 0x0C, 0xFF, 0x00, 0x12, 0xB0, 0x00, 0x09, 0xFF, 0xFF, 0xFF, 0x70,
    0x00, 0x0D, 0x00, 0x12, 0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xFF,
    0xFB, 0x00, 0x00, 0x08, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x08, 0xFF, 0x00, 0x08, 0xFE, 0x10, 0x00,
    0x5F, 0x0C, 0xFF, 0x00, 0x12, 0x30, 0x00, 0x2F, 0xFF, 0xFF, 0xFF, 0xD0,
    0x00, 0x05, 0x00, 0x12, 0xFF, 0x00, 0x18, 0xFD, 0x00, 0x02, 0xFF, 0xFF,
    0xFF, 0xA0, 0x00, 0x00, 0x8F, 0xFF, 0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0A, 0xFF, 0x00, 0x06, 0x80, 0x00, 0x08,
    0x00, 0x0A, 0xFF, 0x00, 0x16, 0xF6, 0x00, 0x00, 0xAF, 0xFF, 0xFF, 0xFF,
    0xF8, 0x00, 0x00, 0x8F, 0x00, 0x08, 0xFF, 0x00, 0x20, 0xFC, 0x4F, 0xFF,
    0xFF, 0xFD, 0x00, 0x02, 0xFF, 0xFF, 0xFF, 0xF9, 0x00, 0x00, 0x08, 0xFF,
    0xFF, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0A,
    0xFF, 0x00, 0x16, 0xF5, 0x00, 0x00, 0x5F, 0xFF, 0xFF, 0xFF, 0xFE, 0x40,
    0x00, 0x07, 0x00, 0x0A, 0xFF, 0x00, 0x06, 0x30, 0x00, 0x07, 0x00, 0x08,
    0xFF, 0x00, 0x0E, 0xA1, 0x04, 0xEF, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x08,
    0xFF, 0x00, 0x0A, 0x90, 0x00, 0x00, 0x8F, 0xFF, 0x00, 0x00, 0x00, 0x0C,
    0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0C, 0xFF, 0x00, 0x14, 0x40,
    0x00, 0x01, 0x8C, 0xFF, 0xFB, 0x80, 0x00, 0x00, 0x6F, 0x0A, 0xFF, 0x00,
    0x1C, 0xD2, 0x00, 0x00, 0x28, 0xFF, 0xFF, 0x84, 0x00, 0x00, 0x3E, 0xFF,
    0xFD, 0x00, 0x02, 0x08, 0xFF, 0x00, 0x0A, 0xF8, 0x00, 0x00, 0x08, 0xFF,
    0x00, 0x00, 0x00, 0x0C, 0xFF, 0x00, 0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0C,
    0xFF, 0x02, 0xF7, 0x0E, 0x00, 0x02, 0x08, 0x0C, 0xFF, 0x02, 0xFE, 0x02,
    0x40, 0x0E, 0x00, 0x00, 0x0A, 0x8E, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x0A,
    0xFF, 0x00, 0x08, 0x80, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x0C, 0xFF, 0x00,
    0x06, 0xB0, 0x00, 0x0D, 0x00, 0x0E, 0xFF, 0x02, 0xC4, 0x0A, 0x00, 0x02,
    0x05, 0x02, 0xDF, 0x0E, 0xFF, 0x02, 0xF9, 0x02, 0x20, 0x0A, 0x00, 0x00,
    0x0C, 0x5C, 0xFF, 0xFF, 0xFD, 0x00, 0x02, 0x0A, 0xFF, 0x00, 0x08, 0xF8,
    0x00, 0x00, 0x06, 0x00, 0x00, 0x22, 0xFF, 0x00, 0x0C, 0xD8, 0x50, 0x00,
    0x00, 0x68, 0xEF, 0x12, 0xFF, 0x00, 0x0C, 0xFA, 0x82, 0x00, 0x00, 0x08,
    0x8E, 0x1E, 0xFF, 0x00, 0x01};
bool dirty = true;


class Screen : public Adafruit_ST7789
{
public:
    Screen(int8_t cs, int8_t dc, int8_t rst, int8_t lite)
        : Adafruit_ST7789(cs, dc, rst)
    {
        LITE_PIN = lite;
    }

    boolean enabled = true;
    int8_t LITE_PIN;
    // storage variables for getTextBounds()
    int16_t xTB, yTB = 0;
    uint16_t wTB = Adafruit_GFX::width();
    uint16_t hTB = Adafruit_GFX::height();

    // TODO: hardcoded is sad
    // but current BMP compressed encoding
    // doesn't include image size
    // width = 106, height = 40, cursor inital position x=0,y=0
    Bitmap bmp = {106, 40, 0, 0};

    void enable()
    {
        enableDisplay(true);
        enabled = true;
    }

    void disable()
    {
        enableDisplay(false);
        enabled = false;
    }

    void drawSplash()
    {
        unsigned int scanPad;
        bool done = false;
        setCursorForCenteredImageDraw(width(), height());

#if DEBUG
        long now = millis();
#endif

        while (!done)
        {
            scanPad = getNextChunk();
            if ((scanPad >> 8) == 0)
            {
                const int chunkLowByte = scanPad & 0x00FF;
                // 0,1,2 are escape values for encoded mode
                // values >= 3 are absolute mode
                switch (chunkLowByte)
                {
                // EOL, go to start of next line
                case 0:
                    bmp.cursorX = width() / 2 - bmp.width / 2;
                    bmp.cursorY++;
                    break;
                // EOF
                case 1:
                    done = true;
                    break;
                // Delta, following two bytes are horizontal & vertical
                // offsets to next pixel relative to current position
                case 2:
                    scanPad = getNextChunk();
                    bmp.cursorX += scanPad >> 8;
                    bmp.cursorY += chunkLowByte;
                    break;
                default:
                {
                    // absolute mode, scanPad is # of indexes
                    // sorry i didn't say indices
                    const int numIndexes = chunkLowByte;
                    for (int j = 0; j < numIndexes; j += 2)
                    {
                        scanPad = getNextChunk(1);
                        drawHighPixel(scanPad);
                        drawLowPixel(scanPad);
                    }
                    // adjust for word boundary alignment by chewing up padding byte
                    if (numIndexes % 4 > 1)
                    {
                        getNextChunk(1);
                    }
                }
                }
            }

            else
            {
                // definitely encoded
                const int repeatLength = scanPad >> 8;
                scanPad &= 0x00FF;

                int drawIndex = 0;

                while (drawIndex < repeatLength)
                {
                    drawHighPixel(scanPad);
                    drawIndex++;
                    // odd number of pixels, bail early
                    if (drawIndex == repeatLength)
                    {
                        continue;
                    }
                    drawLowPixel(scanPad);
                    drawIndex++;
                }
            }
        }
#if DEBUG
        now = millis() - now;
        char doneText[16] = "done";
        int mspad = sprintf(doneText, "done: %li", now);
        sprintf(&doneText[mspad], "ms");

        setTextSize(2);
        getTextBounds(doneText, 0, 0, &xTB, &yTB, &wTB, &hTB);
        setCursor(width() / 2 - (wTB / 2), height() - hTB - 10);
        setTextColor(0x00);
        print(doneText);
        debugln("splash done.");
#endif
    }

    void init()
    {
        pinMode(LITE_PIN, OUTPUT);
        analogWrite(LITE_PIN, 0);
        Adafruit_ST7789::init(240, 320);

        if (!enabled)
        {
            fillScreen(0x00);
            enableSleep(true);
            disable();
            return;
        }

        setRotation(2);
        fillScreen(0xFFFF);

        for (int i = 0; i < MAX_BACKLIGHT_BRIGHTNESS; i++)
        {
            analogWrite(LITE_PIN, i);
            if (i == MAX_BACKLIGHT_BRIGHTNESS)
            {
                break;
            }
            delay(BOOT_FADE_IN_TIME_MS / MAX_BACKLIGHT_BRIGHTNESS);
        }

        drawSplash();
        delay(1200);

        fillScreen(0x00);
        setTextColor(0xFFFF);
        setTextSize(2);

        char title[] = {"Current:"};

        getTextBounds(title, 0, 0, &xTB, &yTB, &wTB, &hTB);
        setCursor(120 - (wTB / 2), 5);
        print(title);
    }

    void updateDisplay(TockTimer cT, int (*func)(TockTimer *t)) {
        TockTimer storage;
  const char queued[] = {"Coming Up:"};
  if (dirty)
  {
    int cursorStart = 30;
    setTextColor(TimerColor[cT.status], 0x0000);
    setCursor(15, cursorStart);
    print(statusType[cT.status]);
    print(" for ");
    print(cT.initialTimeInMS / 1000);

    setTextColor(0xFFFF);
    getTextBounds(queued, 0, 0, &xTB, &yTB, &wTB, &hTB);
    setCursor(120 - (wTB / 2), 70);
    print(queued);

    cursorStart = 95;

    int result = func(&storage);
    while (result && storage.status != 0 && dirty)
    {
      long curColor = TimerColor[storage.status];
      curColor = (curColor >> 8 & 0xf800) | (curColor >> 5 & 0x07e0) | (curColor >> 3 & 0x001f);
      setTextColor(curColor, 0x0000);
      setCursor(15, cursorStart);
      print(statusType[storage.status]);
      print(" for ");
      print(storage.initialTimeInMS / 1000);
      cursorStart += 25;
      // debug(storage.status);
      // debug(" for ");
      // debugln(storage.initialTimeInMS/1000);
      // debugln(result);
      result = func(&storage);
    }
  }}

private:
    unsigned int getNextChunk(byte numBytes = 2, const byte data[]=splashImageData)
    {
        static int idx = 0;
        unsigned int ret;
        if (numBytes == 1)
        {
            ret = pgm_read_byte(data + idx);
            idx++;
        }
        else
        {
            ret = pgm_read_word(data + idx);
            // Little-endian, swap the bytes around
            // so our consumer gets the individual bytes in order
            ret = (ret >> 8) | (ret << 8);
            idx += 2;
        }

        return ret;
    }

    void advanceCursor(int numPixelsDrawn = 1)
    {
        // BMP format doesn't wrap pixels around boundaries, so we can skip that check
        // all line advancement should be handled when we hit a 0x00 0x00 in the scan pad
        // so I thiiiiiiink this really only ever needs to advance x
        bmp.cursorX += numPixelsDrawn;
    }

    void setCursorForCenteredImageDraw(int canvasWidth, int canvasHeight)
    {
        bmp.cursorX = canvasWidth / 2 - bmp.width / 2;
        bmp.cursorY = canvasHeight / 2 - bmp.height / 2;
    }

    // TODO: Can probably accelerate this with some of the drawLine functions
    void drawPixel(unsigned int color)
    {

        // TODO: bg color checking
        if (color != 0x0F)
        {
            // RGB565
            color = (color << 1 | color >> 3) << 11 | (color << 2 | color >> 2) << 5 | (color << 1 | color >> 3);

            Adafruit_ST7789::drawPixel(bmp.cursorX, bmp.cursorY, (uint16_t)color);
        }

        advanceCursor();
    }

    void drawHighPixel(unsigned int colorByte)
    {
        // get just the high bits & move them to the low 4 bits for 565'ing
        // always sits in the high 4 bits of the low byte
        unsigned int color = (colorByte & 0x00FF) >> 4;
        drawPixel(color);
    }

    void drawLowPixel(unsigned int colorByte)
    {
        // get just the low 4 bits of the low byte
        unsigned int color = colorByte & 0x000F;
        drawPixel(color);
    }
};
#endif